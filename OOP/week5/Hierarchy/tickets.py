from abc import ABC, abstractmethod
from typing import Optional, Dict, Any
from datetime import datetime, timedelta

class ПроезднойБилет(ABC):
    """
    Абстрактный базовый класс для всех типов проездных билетов.
    Описание: Определяет общий интерфейс и базовую функциональность для билетов.
    """
    
    def __init__(self, номер: str, дата_активации: Optional[datetime] = None):
        """
        Инициализация базового билета.
        Параметры:
            номер: Уникальный номер билета
            дата_активации: Дата активации билета (по умолчанию None)
        """
        self._номер = номер
        self._дата_активации = дата_активации
        self._активирован = False
        self.__секретный_код = self._сгенерировать_код()
        
    def _сгенерировать_код(self) -> str:
        """Генерирует секретный код для билета"""
        return f"CODE-{self._номер[-4:]}-{id(self) % 10000:04d}"
    
    def активировать(self) -> None:
        """Активирует билет"""
        if not self._активирован:
            self._дата_активации = datetime.now()
            self._активирован = True
            print(f"Билет {self._номер} активирован {self._дата_активации}")
        else:
            print(f"Билет {self._номер} уже активирован")
    
    @abstractmethod
    def списать_поездку(self) -> bool:
        """
        Списывает одну поездку с билета.
        Результат:
            True если поездка списана успешно, иначе False
        """
        pass
    
    @property
    def номер(self) -> str:
        """Возвращает номер билета"""
        return self._номер
    
    @property
    def активен(self) -> bool:
        """Проверяет активен ли билет"""
        return self._активирован
    
    def __call__(self) -> Dict[str, Any]:
        """
        Вызываемый метод, возвращает информацию о билете.
        Результат:
            Словарь с основной информацией о билете
        """
        return {
            'номер': self._номер,
            'активирован': self._активирован,
            'дата_активации': self._дата_активации.isoformat() if self._активирован else None
        }
    
    def __str__(self) -> str:
        """Строковое представление билета"""
        статус = "Активирован" if self._активирован else "Не активирован"
        return f"Билет {self._номер} ({статус})"

class БилетСОграничением(ПроезднойБилет):
    """
    Базовый класс для билетов с ограничениями.
    Описание: Реализует общую логику для билетов с ограничениями по времени или количеству.
    """
    
    def __init__(self, номер: str, срок_действия: timedelta):
        """
        Инициализация билета с ограничением.
        Параметры:
            номер: Уникальный номер билета
            срок_действия: Срок действия билета после активации
        """
        super().__init__(номер)
        self._срок_действия = срок_действия
        self._дата_окончания: Optional[datetime] = None
    
    @property
    def действителен(self) -> bool:
        """Проверяет действительность билета"""
        if not self._активирован:
            return False
        return datetime.now() < self._дата_окончания
    
    def активировать(self) -> None:
        """Активирует билет и устанавливает дату окончания"""
        super().активировать()
        if self._активирован and self._дата_активации:
            self._дата_окончания = self._дата_активации + self._срок_действия
            print(f"Билет действителен до {self._дата_окончания}")
    
    def __call__(self) -> Dict[str, Any]:
        """Дополняет информацию о билете данными об окончании действия"""
        data = super().__call__()
        data['дата_окончания'] = self._дата_окончания.isoformat() if self._дата_окончания else None
        data['действителен'] = self.действителен
        return data

class БилетСОграничениемПоездок(БилетСОграничением):
    """
    Билет с ограничением по количеству поездок.
    Описание: Позволяет совершить определенное количество поездок в течение срока действия.
    """
    
    def __init__(self, номер: str, срок_действия: timedelta, количество_поездок: int):
        """
        Инициализация билета.
        Параметры:
            номер: Уникальный номер билета
            срок_действия: Срок действия билета после активации
            количество_поездок: Общее количество доступных поездок
        """
        super().__init__(номер, срок_действия)
        self._количество_поездок = количество_поездок
        self._осталось_поездок = количество_поездок
    
    def списать_поездку(self) -> bool:
        """Списывает одну поездку с билета"""
        if not self.действителен:
            print(f"Билет {self._номер} недействителен")
            return False
        
        if self._осталось_поездок <= 0:
            print(f"В билете {self._номер} закончились поездки")
            return False
        
        self._осталось_поездок -= 1
        print(f"Списана поездка. Осталось: {self._осталось_поездок}/{self._количество_поездок}")
        return True
    
    def __call__(self) -> Dict[str, Any]:
        """Дополняет информацию о билете данными о поездках"""
        data = super().__call__()
        data['поездки'] = f"{self._осталось_поездок}/{self._количество_поездок}"
        return data
    
    def __str__(self) -> str:
        """Строковое представление билета"""
        base = super().__str__()
        return f"{base} Поездок: {self._осталось_поездок}/{self._количество_поездок}"

class БезлимитныйБилет(ПроезднойБилет):
    """
    Безлимитный проездной билет.
    Описание: Позволяет неограниченное количество поездок в течение срока действия.
    """
    
    def __init__(self, номер: str, срок_действия: timedelta):
        """
        Инициализация безлимитного билета.
        Параметры:
            номер: Уникальный номер билета
            срок_действия: Срок действия билета после активации
        """
        super().__init__(номер)
        self._срок_действия = срок_действия
        self._дата_окончания: Optional[datetime] = None
    
    def списать_поездку(self) -> bool:
        """Списывает одну поездку (всегда успешно, пока билет действителен)"""
        if not self.действителен:
            print(f"Билет {self._номер} недействителен")
            return False
        
        print(f"Списана поездка с безлимитного билета {self._номер}")
        return True
    
    @property
    def действителен(self) -> bool:
        """Проверяет действительность билета"""
        if not self._активирован:
            return False
        return datetime.now() < self._дата_окончания
    
    def активировать(self) -> None:
        """Активирует билет и устанавливает дату окончания"""
        super().активировать()
        if self._активирован and self._дата_активации:
            self._дата_окончания = self._дата_активации + self._срок_действия
            print(f"Билет действителен до {self._дата_окончания}")
    
    def __call__(self) -> Dict[str, Any]:
        """Дополняет информацию о билете данными об окончании действия"""
        data = super().__call__()
        data['дата_окончания'] = self._дата_окончания.isoformat() if self._дата_окончания else None
        data['действителен'] = self.действителен
        return data
    
    def __str__(self) -> str:
        """Строковое представление билета"""
        base = super().__str__()
        return f"{base} Безлимитный (до {self._дата_окончания})"